HTML & CSS Notes


Basic html page template:

<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='UTF-8' />
    <title>Title</title>
    <link rel='stylesheet' href='styles.css'/>
  </head>
  <body>
    <div class='page'>
      <div class='menu'>Menu</div>
      <div class='sidebar'>Sidebar</div>
      <div class='content'>Content</div>
      <div class='footer'>Footer</div>
    </div>
  </body>
</html>



Some CSS sizing rules from the internet:

----
px: Setting base size for your project (define on body). Typically used minimally, with em doing the brunt of hte work

rem: Setting relative size (headings, body text, etc). Used liberally for 'generic ui elements' and often avoided for specifics.

em: Setting styles inline with your content (subscript, superscript, 'effects' on your items that are dependent on the item's size, etc). Used liberally for 'custom ui elements' and often avoided for generics. iirc it represents uppercase letter scale of the font.

vw/vh: Filling viewports, often used alongside media queries. Typically used for wrappers around your content.

vmin/vmax: Filling viewports based on the smallest/largest available size, often used alongside media queries. Typically used for wrappers around your content.

%: use when parent is a fixed size, or to 100% fill a container, often used alongside media queries. Typically used in subwrappers to scale content.

ch: explicitly defining width of a section of text, typically used for paragraphs and inputs

lh: vertically aligning block elements with text, typically used with inline block elements that need to be aligned along a center horizontal axis

ex: rarely used over em, but typically for vertical measurements of text. iirc represents lowercase letter scale of the font.
----
----
Rem for general sizing ( texts, margin, paddings, etc) bonus points if you enforce a scale ( for example always use multiples of 4 ) -em for text size relative to parent

Vw/vh when you need to do something relative to screen size ( "I want this element to be exactly half the screen height" )

% is usually used along with transforms or sizing of elements relative to parent.
----



HTML:

<em> and <strong> can be used in-line to make a text italic or bold respectively.

<div> and <span> are similar, one is block-type, other is inline.

We can link to certain parts of a page by providing an id to the element we want to focus on and adding it at the end of the href of an a link:
<p id="focus-target"></p>
...
<a href="index.html#focus-target"></a> (index.html being the page the p is part of)
If we link to an element on the same page, we can ommit the URL entirely and only point to #focus-target


HTML Semantics:

h1-h6 for headers.

<article> : The <article> element represents an independent article in a web page. It should only wrap content that can be plucked out of your page and distributed in a completely different context.
<article>’s are essentially mini web pages in your HTML document. They have their own headers, footers, and document outline that are completely isolated from the rest of your site.

<section> : The <section> element is sort of like an <article>, except it doesn’t need to make sense outside the context of the document. 
Also note that each <section> element should contain at least one heading, otherwise it will add an “untitled section” to your document outline. This should generally be avoided when using <section> elements.

<nav> : 
The <nav> element lets you mark up the various navigation sections of your website. This goes for the main site navigation, links to related pages in a sidebar, tables of content, and pretty much any group of links. 

<header> : The <header> element is a new piece of semantic markup, not to be confused with headings (the <h1>-<h6> elements). It denotes introductory content for a section, article, or entire web page. “Introductory content” can be anything from your company’s logo to navigational aids or author information.

<footer> : Conceptually, footers are basically the same as headers, except they generally come at end of an article/website opposed to the beginning. Common use cases include things like copyright notices, footer navigation, and author bios at the end of blog posts.

<aside> : Headers and footers are ways to add extra information to an article, but sometimes we want to remove information from an article. For example, a sponsored blog post might contain an advertisement about the sponsoring company; however, we probably don’t want to make it part of the article text. This is what the <aside> element is for.
In addition to advertisements, <aside> is also appropriate for highlighting definitions, stats, or quotations. If it looks different than the rest of the article, chances are it’s an aside.

We can also use asides, headers and footers within sections and articles to better structure them.

<time> : The <time> element represents either a time of day or a calendar date. Providing a machine-readable date makes it possible for browsers to automatically link it to users’ calendars and helps search engines clearly identify specific dates.
ex: <time datetime='2017-1-3'>January 3rd</time>
The machine-readable date is defined in the datetime attribute. An easy way to remember the date format is that it goes from largest time period to smallest: year, month, then date. Note that even though the year isn’t included in the human-readable text, this tells search engines that our article was published in 2017.
It’s possible to include times and time zones inside of datetime, too. If we wanted to add a 3:00pm PST time to our publish date, we’d use the following:
<time datetime='2017-1-3 15:00-0800'>January 3rd</time>
The time itself is in 24-hour format, and the -0800 is the time zone offset from GMT (in this case, -0800 represents Pacific Standard Time).

<address> : The <address> element is like <time> in that it doesn’t deal with the overall structure of a document, but rather embellishes the parent <article> or <body> element with some metadata. It defines contact information for the author of the article or web page in question. <address> should not be used for arbitrary physical addresses.
ex: <address>
    Please contact <a href='mailto:troymcclure@example.com'>Troy
    McClure</a> for questions about this article.
  </address>
By default, this will be styled the same way as <em>, but you can change that with a simple CSS rule.

<figure> and <figcaption> : Last, but certainly not least, are the <figure> and <figcaption> elements. The former represents a self-contained “figure”, like a diagram, illustration, or even a code snippet. The latter is optional, and it associates a caption with its parent <figure> element.

A common use case for both of these is to add visible descriptions to the <img/> elements in an article, like so:

<section>
  <h2>The Document Outline</h2>
  <p>HTML5 includes several “sectioning content” elements that
    affect the document outline.</p>

  <figure>
    <img src='semantic-elements.png'
         alt='Diagram showing <article>, <section>, and <nav> elements'/>
    <figcaption>New HTML5 semantic elements</figcaption>
  </figure>
  <!-- ... -->
The alt attribute is closely related to the <figcaption> element. alt should serve as a text replacement for the image, while <figcaption> is a supporting description displayed with either the image or its text-based equivalent.

When using <figcaption> in the above manner, you can safely omit an image’s alt attribute without hurting your SEO. Depending on what kind of images you’re working with, it may be more convenient (and less redundant) to have visible <figcaption>’s that describe them opposed to invisible alt attributes.

All these semantics elements were introduced in HTML5. For legacy browsers, we should add the following line in CSS, so that they will be treated as block boxes (like div's):

section, article, aside, footer, header, nav {
  display: block;
}



CSS:

display defines type of box: none (hidden), block, inline, inline-box, flex, flexbox, etc. Difference between inline and inline-block is that inline-block allows to set a width and height and also it doesn not ignore top and bottom margins/paddings. Difference between block and inline-block is that inline-block does not add a line-break after the element, so the element can sit next to other elements.

padding/margin template: top right bottom left OR verticla horizontal. ex: padding: 20px 10px 20px 10px is same as 20px 10px

border template: size style color. ex: border: 1px solid red;

Bullet icons for <li> can be altered using list-style-type (circle, lower-roman, etc), or even using list-style-image for a custom bullet. None removes any bullets, being useful for things like navigation menus.

text-decoration can be used to underline or dash through a text.

font-weight can be used to make text bold/normal, while font-style can make it italic/normal.

Inline boxes ignore margin top/bottom, but take into consideration padding top/bottom. Left/right are unaffected on both.

Margin collapse: having two boxes on top of each other, each with their own margin, makes the margin collapse (on top of each other), meaning if one has a margin of 50px and the other 25px, the total margin will be 50px (the bigger of the two). This can be avoided through a number of methods: only set margin-top or margin-bottom on all elements or add an invisible div with a styling of padding:1px between the two elements, which will act as a border. If using flexbox, margins don't collapse and this problem does not apply.

box-sizing: content-box vs border-box -> setting width/height, context-box doesn't take into account padding and border (meaning total width is our width + border + padding). For border-box, the total width includes padding and border (so basically it will be our width - padding - borders)

For text-alignment, we have text-align (right, left, center, etc). For content alignemnt, we have auto margins, floats or flexbox. Floats and flexbox will be covered later. For auto margins, we need to set the width/height for each margin set (if we want to only set margin auto horizontally, we only need width, if we only want it vertically, we need height, for both, you get the idea). It is set to auto by replacing the size with auto: 
margin: 20px auto (top/bottom margin of 20px and centered on right/left)

To override default styles, we can use the universal CSS selector, "*":
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
This would eliminate the default margins and paddings set by the browser by default.

Classes precedence: if we have two classes that modify the same property and both of them ge applied to the same element, the class lower down in the css file takes precedence (if multiple css files are loaded, the class in the latest loaded css file applies)
ex: 
<p class="first-class second-class"></p>
.first-class {
	width: 300;
	height: 200;
}
.second-class {
	height: 100;
}
p will have a width and height of 300/100.
class="first-class second-class" and class="second-class first-class" are the same, order here does not affect precedence.


Child combinator: we can style direct children of elements by using the ">" sign. ex: div > .testClass will reffer to children of divs that have the class of testClass.

Main pseudo-classes for links: a:link, a:visited, a:hover, a:active . Can be combined, such as a:visited:hover (hover over visited link) or a:visited:active (clicking on visited link)

Precedence is overriden by specificity. Order is as follows (from greatest to least):
- id selectors: #button-2
- class + pseudo-class: .button:link
- element type + pseudot-class AND class + children: a:link AND .some-class p
- class selectors: .button
- element type selectors: div


Floats:
float right/left to align block elements to right or left (margin auto still for center). 
clear: right/left/both to make an element ignore float right/left or both.

By adding an "overflow: hidden" declaration to a container div, we’re telling it to recognize the height of any floated elements it contains.

To summarize, when you have an extra unfloated HTML element at the bottom of a container div, use the clear solution. Otherwise, add an overflow: hidden declaration to the container element. The underlying idea for both options is that you need a way to tell the browser to incorporate floats into the height of their container element in order for their backgrounds to show up.


FLEXBOX:

We define an element as a flex container by adding "display: flex;" to its CSS. 

We align items horizontally within the flex container with the property justify-content and values: flex-start / center / flex-end / space-around / space-between. These are applied to the container, not the child elements.

We align items vertically within the flex container with the property align-center and values: center, flex-start (top), flex-end (bottom), stretch, baseline. Stretch stretches the element on the full height of the parent. For baseline, check https://stackoverflow.com/questions/34606879/whats-the-difference-between-flex-start-and-baseline. For short, flex-start aligns the top of the child items, baseline aligns the bottoms of the content of the child items.

space-around and space-between automatically distributes space to either side of each item of the container. The difference between the two is that space-around also allocates space before the first item and after the last, while the space-between one only allocates space between elements.

We can modify the orientation of our flex items by using flex-direction. For example, default is row (horizontal), but we can opt for column for vertical alignment. If we switch to vertical alignment, horizontal and vertical alignment properties switch, justify-content being for verticality and vice-versa. We can also use row-reverse or column-reverse to display items in reverse order.

We can align the items within a container (children) with align-items.

The flex-wrap CSS property sets whether flex items are forced onto one line or can wrap onto multiple lines. If wrapping is allowed, it sets the direction that lines are stacked.
ex: flex-wrap: nowrap; /* Default value */
flex-wrap: wrap;
flex-wrap: wrap-reverse;

flex-flow : flex-flow is the combination of flex-direction and flex-wrap. It accepts two values, which are the values we would give to direction and wrap.
ex: flex-flow: column wrap /// flex-flow: column-reverse wrap-reverse /// etc...

You can use align-content to set how multiple lines are spaced apart from each other. This property takes the following values:

flex-start: Lines are packed at the top of the container.
flex-end: Lines are packed at the bottom of the container.
center: Lines are packed at the vertical center of the container.
space-between: Lines display with equal spacing between them.
space-around: Lines display with equal spacing around them.
stretch: Lines are stretched to fit the container.

This can be confusing, but align-content determines the spacing between lines, while align-items determines how the items as a whole are aligned within the container. When there is only one line, align-content has no effect.


FLEX ITEM ORDER:

We can add an order property to flex items (default is 0) so that we can move it right or left (can take negative numbers).

We can use align-self on item classes in order to override the align-items of the parent container.

Using the flex property, we can set the ratio of space that a particular element should ocupy of the parent. For example, if we add 3 elements to a parent and set flex: 0.3; each element will take 30% of the parent and leave 10% free space. Setting it to 1 will mean all elements will take equal parts of the whole space. Setting two of them to 1 and the last to 2 will mean the last one will take twice as much space as each of the other two. This can help us with scaling individual containers within their parents.

We can use flex: initial; on individual items and set static sizes. 
Ex: we can set a general flex: 1 to 3 items, then on two individual items set a flex: initial; with width of 300px; On resizing the page, the one item that has a flex of 1 will be resized, while the ones that have a width of 300px will stay the same.

There is also the "auto" option for flex, which automatically sizes the containers based on how much space their content is taking.

An alternative to using extra divs in order to align a group of items to the left or right, we can use margin-left/margin-right: auto, which uses up all the space left to the side of the element (margin-left: auto "glues" the element to the right of the container, opposite for margin-right). So we can use, for example, justify-content: space-between for 3 elements, but we want the last two to be next to each other. We can put the last two in a separate container, but to avoid this, we can set the middle one to margin-left: auto, which would yield the same result.


CSS GRID:

To set an element as a grid container, we use display: grid;

We can set how many columns/rows an element should take of the container using the properties grid-column-start/grid-column-end, grid-row-start/grid-row-end, grid-column (start and end combined), grid-row (start and end combined) or grid-area (all 4 combined).
ex: grid-column-start: 1
grid-row: 2 / 5
grid-area: 1 / 1 / 3 / 5



POSITIONING:

Available positions: static (default), relative, absolute, fixed. Relative means the offset is relative to the original object position (where it should be with static positioning). Absolute is relative to the browser window (left 30px for example will place it 30px right of the left edge of the browser window), except for special cases (see below). Fixed is almost the same as absolute, only the element does not scroll with the rest of the page (this is how we can achieve those cool effects where the background or certain elements stay static on the page when scrolling).

Coordinates for absolute elements are always relative to the closest container that is a positioned element. It only falls back to being relative to the browser when none of its ancestors are positioned. So, if any ancestor of our element has another position other than static set, it would be absolute in accordance to that ancestor.

Another effect of absolute positioning is the fact that the element is removed from the flow. For example, if we had 3 elements inside a container and set it to flexbox, with a justify of flex-start, all 3 elements will be placed one after the other. If we'd set the middle one to position: absolute, the first and third element would now be next to each other and the second one would be "floating" above them.

The top, bottom, left, and right properties are used with position to set the placement of an element. They only have an effect on positioned elements, which are elements with the position property set to anything other than static. For example: relative, absolute, fixed, or sticky. ex: {position: relative; top: 1px;}

Top moves it down, left moves it right, and so on. Negative values can be used to achieve the opposite effect (top: 10px is the same as bottom: -10px).


Elements Depth (Z-Index)

You can set which elements should be on top of others using the z-index. The higher this index, the bigger the priority. (z-index 2 will be in front of z-index 1).



RESPONSIVE DESIGN:

This should be added in the html under the <head> tag in order for media queries to work:

<meta name="viewport" content="width=device-width, initial-scale=1">

To disable viewport zooming, add this:

<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0' />


Media queries always begin with the @media “at-rule” followed by some kind of conditional statement, and then some curly braces. Inside the curly braces, you put a bunch of ordinary CSS rules. The browser only pays attention to those rules if the condition is met.

example:
at-rule  media type            media feature
@media   only screen   and   (max-width: 400px) {
	<some css rules...>
}

The only screen “media type” means that the contained styles should only be applied to devices with screens (opposed to printed documents, like when you hit Cmd+P in a browser). The min-width and max-width parts are called “media features”, and they specify the device dimensions you’re targeting.

More info: https://developer.mozilla.org/en-US/docs/Web/CSS/@media


RESPONSIVE IMAGES:

SVG's are vector-based, so they will automatically fit the page regardless of resolution. For Chrome, we need to add a styling to the image in order for this to apply: width: 100%; If we don't, the image will always stay the same size on window resizing.

Retina vs non-retina displays: 

We can set multiple sources for an image for retina or non-retina displays, using srcset:

<img src='illustration-small.png'
       srcset='images/illustration-small.png 1x,
               images/illustration-big.png 2x'
       style='max-width: 500px'/>

The srcset attribute points to a list of alternative image files, along with properties defining when the browser should use each of them. The 1x tells the browser to display illustration-small.png on standard-resolution screens. The 2x means that illustration-big.png is for retina screens. Older browsers that don’t understand srcset fall back to the src attribute.

OR

<img src='images/photo-small.jpg'
         srcset='images/photo-big.jpg 2000w,
                 images/photo-small.jpg 1000w'
         sizes='(min-width: 960px) 960px,
                100vw'/>

We have the same srcset element as the last section, but instead of the 1x and 2x descriptors, we’re providing the inherent physical width of the image. The 2000w tells the browser that the photo-big.jpg file is 2000 pixels wide. Likewise, the 1000w means photo-small.jpg has a width of 1000 pixels. If you’re wondering about that w character, it’s a special unit used only for this kind of image optimization scenario.

Image width alone isn’t enough for a device to determine which image it should load. We also need to tell it what the final rendered width of the image will be. That’s where the sizes attribute comes in. It defines a series of media queries along with the image’s rendered width when that media query is in effect.


An alternative would be the usage of the <picture> and <source> elements. The former is just a wrapper, and the latter conditionally loads images based on media queries.
ex:
<picture>
      <source media='(min-width: 401px)'
              srcset='images/photo-big.jpg'/>
      <source media='(max-width: 400px)'
              srcset='images/photo-tall.jpg'/>
      <img src='images/photo-small.jpg'/>
    </picture>

Conceptually, this is pretty similar to using media queries in CSS. In each <source> element, the media attribute defines when the image should be loaded, and srcset defines which image file should be loaded. The <img/> element is only used as a fallback for older browsers.


While it is possible to combine the best of both worlds, it gets complicated real quick. Our recommendation is to stick to the 1x and 2x version of srcset for images less than 600 pixels wide, use the srcset plus sizes method from the previous section for bigger photos, and reserve <picture> for when you’re trying to do something real fancy with your designer.



MISCELANEOUS:

cursor: pointer; changes the cursor to a pointer upon hover.

How to display an element on hover with CSS example:
CSS:  .dropdown:hover .features-menu {
		  display: flex;                    /* Leave everything else alone */
		  flex-direction: column;
		  background: #B2D6FF;
	      etc......
	  }

	  .features-menu {
	    display: none;
	  }

HTML: <li class="dropdown">
		<span>Features ▾</span>
		<ul class="features-menu">
			...
		</ul>
	</li>			









